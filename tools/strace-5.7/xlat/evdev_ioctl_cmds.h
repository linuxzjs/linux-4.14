/* Generated by ./xlat/gen.sh from ./xlat/evdev_ioctl_cmds.in; do not edit. */

#include "gcc_compat.h"
#include "static_assert.h"

#if defined(EVIOCGVERSION) || (defined(HAVE_DECL_EVIOCGVERSION) && HAVE_DECL_EVIOCGVERSION)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGVERSION) == (_IOR('E', 0x01, int)), "EVIOCGVERSION != _IOR('E', 0x01, int)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGVERSION _IOR('E', 0x01, int)
#endif
#if defined(EVIOCGID) || (defined(HAVE_DECL_EVIOCGID) && HAVE_DECL_EVIOCGID)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGID) == (_IOR('E', 0x02, struct input_id)), "EVIOCGID != _IOR('E', 0x02, struct input_id)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGID _IOR('E', 0x02, struct input_id)
#endif
#if defined(EVIOCGREP) || (defined(HAVE_DECL_EVIOCGREP) && HAVE_DECL_EVIOCGREP)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGREP) == (_IOR('E', 0x03, unsigned int[2])), "EVIOCGREP != _IOR('E', 0x03, unsigned int[2])");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGREP _IOR('E', 0x03, unsigned int[2])
#endif
#if defined(EVIOCSREP) || (defined(HAVE_DECL_EVIOCSREP) && HAVE_DECL_EVIOCSREP)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCSREP) == (_IOW('E', 0x03, unsigned int[2])), "EVIOCSREP != _IOW('E', 0x03, unsigned int[2])");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCSREP _IOW('E', 0x03, unsigned int[2])
#endif
#if defined(EVIOCGKEYCODE) || (defined(HAVE_DECL_EVIOCGKEYCODE) && HAVE_DECL_EVIOCGKEYCODE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGKEYCODE) == (_IOR('E', 0x04, unsigned int[2])), "EVIOCGKEYCODE != _IOR('E', 0x04, unsigned int[2])");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGKEYCODE _IOR('E', 0x04, unsigned int[2])
#endif
#if defined(EVIOCGKEYCODE_V2) || (defined(HAVE_DECL_EVIOCGKEYCODE_V2) && HAVE_DECL_EVIOCGKEYCODE_V2)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGKEYCODE_V2) == (_IOR('E', 0x04, struct_input_keymap_entry)), "EVIOCGKEYCODE_V2 != _IOR('E', 0x04, struct_input_keymap_entry)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGKEYCODE_V2 _IOR('E', 0x04, struct_input_keymap_entry)
#endif
#if defined(EVIOCSKEYCODE) || (defined(HAVE_DECL_EVIOCSKEYCODE) && HAVE_DECL_EVIOCSKEYCODE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCSKEYCODE) == (_IOW('E', 0x04, unsigned int[2])), "EVIOCSKEYCODE != _IOW('E', 0x04, unsigned int[2])");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCSKEYCODE _IOW('E', 0x04, unsigned int[2])
#endif
#if defined(EVIOCSKEYCODE_V2) || (defined(HAVE_DECL_EVIOCSKEYCODE_V2) && HAVE_DECL_EVIOCSKEYCODE_V2)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCSKEYCODE_V2) == (_IOW('E', 0x04, struct_input_keymap_entry)), "EVIOCSKEYCODE_V2 != _IOW('E', 0x04, struct_input_keymap_entry)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCSKEYCODE_V2 _IOW('E', 0x04, struct_input_keymap_entry)
#endif
#if defined(EVIOCRMFF) || (defined(HAVE_DECL_EVIOCRMFF) && HAVE_DECL_EVIOCRMFF)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCRMFF) == (_IOW('E', 0x81, int)), "EVIOCRMFF != _IOW('E', 0x81, int)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCRMFF _IOW('E', 0x81, int)
#endif
#if defined(EVIOCGEFFECTS) || (defined(HAVE_DECL_EVIOCGEFFECTS) && HAVE_DECL_EVIOCGEFFECTS)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGEFFECTS) == (_IOR('E', 0x84, int)), "EVIOCGEFFECTS != _IOR('E', 0x84, int)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGEFFECTS _IOR('E', 0x84, int)
#endif
#if defined(EVIOCGRAB) || (defined(HAVE_DECL_EVIOCGRAB) && HAVE_DECL_EVIOCGRAB)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGRAB) == (_IOW('E', 0x90, int)), "EVIOCGRAB != _IOW('E', 0x90, int)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGRAB _IOW('E', 0x90, int)
#endif
#if defined(EVIOCREVOKE) || (defined(HAVE_DECL_EVIOCREVOKE) && HAVE_DECL_EVIOCREVOKE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCREVOKE) == (_IOW('E', 0x91, int)), "EVIOCREVOKE != _IOW('E', 0x91, int)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCREVOKE _IOW('E', 0x91, int)
#endif
#if defined(EVIOCGMASK) || (defined(HAVE_DECL_EVIOCGMASK) && HAVE_DECL_EVIOCGMASK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCGMASK) == (_IOR('E', 0x92, struct_input_mask)), "EVIOCGMASK != _IOR('E', 0x92, struct_input_mask)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCGMASK _IOR('E', 0x92, struct_input_mask)
#endif
#if defined(EVIOCSMASK) || (defined(HAVE_DECL_EVIOCSMASK) && HAVE_DECL_EVIOCSMASK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCSMASK) == (_IOW('E', 0x93, struct_input_mask)), "EVIOCSMASK != _IOW('E', 0x93, struct_input_mask)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCSMASK _IOW('E', 0x93, struct_input_mask)
#endif
#if defined(EVIOCSCLOCKID) || (defined(HAVE_DECL_EVIOCSCLOCKID) && HAVE_DECL_EVIOCSCLOCKID)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((EVIOCSCLOCKID) == (_IOW('E', 0xa0, int)), "EVIOCSCLOCKID != _IOW('E', 0xa0, int)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define EVIOCSCLOCKID _IOW('E', 0xa0, int)
#endif

#ifndef XLAT_MACROS_ONLY

# ifdef IN_MPERS

#  error static const struct xlat evdev_ioctl_cmds in mpers mode

# else

static const struct xlat_data evdev_ioctl_cmds_xdata[] = {
 XLAT(EVIOCGVERSION),
 #define XLAT_VAL_0 ((unsigned) (EVIOCGVERSION))
 #define XLAT_STR_0 STRINGIFY(EVIOCGVERSION)
 XLAT(EVIOCGID),
 #define XLAT_VAL_1 ((unsigned) (EVIOCGID))
 #define XLAT_STR_1 STRINGIFY(EVIOCGID)
 XLAT(EVIOCGREP),
 #define XLAT_VAL_2 ((unsigned) (EVIOCGREP))
 #define XLAT_STR_2 STRINGIFY(EVIOCGREP)
 XLAT(EVIOCSREP),
 #define XLAT_VAL_3 ((unsigned) (EVIOCSREP))
 #define XLAT_STR_3 STRINGIFY(EVIOCSREP)
 XLAT(EVIOCGKEYCODE),
 #define XLAT_VAL_4 ((unsigned) (EVIOCGKEYCODE))
 #define XLAT_STR_4 STRINGIFY(EVIOCGKEYCODE)
 XLAT(EVIOCGKEYCODE_V2),
 #define XLAT_VAL_5 ((unsigned) (EVIOCGKEYCODE_V2))
 #define XLAT_STR_5 STRINGIFY(EVIOCGKEYCODE_V2)
 XLAT(EVIOCSKEYCODE),
 #define XLAT_VAL_6 ((unsigned) (EVIOCSKEYCODE))
 #define XLAT_STR_6 STRINGIFY(EVIOCSKEYCODE)
 XLAT(EVIOCSKEYCODE_V2),
 #define XLAT_VAL_7 ((unsigned) (EVIOCSKEYCODE_V2))
 #define XLAT_STR_7 STRINGIFY(EVIOCSKEYCODE_V2)


 XLAT(EVIOCRMFF),
 #define XLAT_VAL_8 ((unsigned) (EVIOCRMFF))
 #define XLAT_STR_8 STRINGIFY(EVIOCRMFF)
 XLAT(EVIOCGEFFECTS),
 #define XLAT_VAL_9 ((unsigned) (EVIOCGEFFECTS))
 #define XLAT_STR_9 STRINGIFY(EVIOCGEFFECTS)
 XLAT(EVIOCGRAB),
 #define XLAT_VAL_10 ((unsigned) (EVIOCGRAB))
 #define XLAT_STR_10 STRINGIFY(EVIOCGRAB)
 XLAT(EVIOCREVOKE),
 #define XLAT_VAL_11 ((unsigned) (EVIOCREVOKE))
 #define XLAT_STR_11 STRINGIFY(EVIOCREVOKE)
 XLAT(EVIOCGMASK),
 #define XLAT_VAL_12 ((unsigned) (EVIOCGMASK))
 #define XLAT_STR_12 STRINGIFY(EVIOCGMASK)
 XLAT(EVIOCSMASK),
 #define XLAT_VAL_13 ((unsigned) (EVIOCSMASK))
 #define XLAT_STR_13 STRINGIFY(EVIOCSMASK)
 XLAT(EVIOCSCLOCKID),
 #define XLAT_VAL_14 ((unsigned) (EVIOCSCLOCKID))
 #define XLAT_STR_14 STRINGIFY(EVIOCSCLOCKID)
};
static
const struct xlat evdev_ioctl_cmds[1] = { {
 .data = evdev_ioctl_cmds_xdata,
 .size = ARRAY_SIZE(evdev_ioctl_cmds_xdata),
 .type = XT_NORMAL,
 .flags_mask = 0
#  ifdef XLAT_VAL_0
  | XLAT_VAL_0
#  endif
#  ifdef XLAT_VAL_1
  | XLAT_VAL_1
#  endif
#  ifdef XLAT_VAL_2
  | XLAT_VAL_2
#  endif
#  ifdef XLAT_VAL_3
  | XLAT_VAL_3
#  endif
#  ifdef XLAT_VAL_4
  | XLAT_VAL_4
#  endif
#  ifdef XLAT_VAL_5
  | XLAT_VAL_5
#  endif
#  ifdef XLAT_VAL_6
  | XLAT_VAL_6
#  endif
#  ifdef XLAT_VAL_7
  | XLAT_VAL_7
#  endif
#  ifdef XLAT_VAL_8
  | XLAT_VAL_8
#  endif
#  ifdef XLAT_VAL_9
  | XLAT_VAL_9
#  endif
#  ifdef XLAT_VAL_10
  | XLAT_VAL_10
#  endif
#  ifdef XLAT_VAL_11
  | XLAT_VAL_11
#  endif
#  ifdef XLAT_VAL_12
  | XLAT_VAL_12
#  endif
#  ifdef XLAT_VAL_13
  | XLAT_VAL_13
#  endif
#  ifdef XLAT_VAL_14
  | XLAT_VAL_14
#  endif
  ,
 .flags_strsz = 0
#  ifdef XLAT_STR_0
  + sizeof(XLAT_STR_0)
#  endif
#  ifdef XLAT_STR_1
  + sizeof(XLAT_STR_1)
#  endif
#  ifdef XLAT_STR_2
  + sizeof(XLAT_STR_2)
#  endif
#  ifdef XLAT_STR_3
  + sizeof(XLAT_STR_3)
#  endif
#  ifdef XLAT_STR_4
  + sizeof(XLAT_STR_4)
#  endif
#  ifdef XLAT_STR_5
  + sizeof(XLAT_STR_5)
#  endif
#  ifdef XLAT_STR_6
  + sizeof(XLAT_STR_6)
#  endif
#  ifdef XLAT_STR_7
  + sizeof(XLAT_STR_7)
#  endif
#  ifdef XLAT_STR_8
  + sizeof(XLAT_STR_8)
#  endif
#  ifdef XLAT_STR_9
  + sizeof(XLAT_STR_9)
#  endif
#  ifdef XLAT_STR_10
  + sizeof(XLAT_STR_10)
#  endif
#  ifdef XLAT_STR_11
  + sizeof(XLAT_STR_11)
#  endif
#  ifdef XLAT_STR_12
  + sizeof(XLAT_STR_12)
#  endif
#  ifdef XLAT_STR_13
  + sizeof(XLAT_STR_13)
#  endif
#  ifdef XLAT_STR_14
  + sizeof(XLAT_STR_14)
#  endif
  ,
} };

#  undef XLAT_STR_0
#  undef XLAT_VAL_0
#  undef XLAT_STR_1
#  undef XLAT_VAL_1
#  undef XLAT_STR_2
#  undef XLAT_VAL_2
#  undef XLAT_STR_3
#  undef XLAT_VAL_3
#  undef XLAT_STR_4
#  undef XLAT_VAL_4
#  undef XLAT_STR_5
#  undef XLAT_VAL_5
#  undef XLAT_STR_6
#  undef XLAT_VAL_6
#  undef XLAT_STR_7
#  undef XLAT_VAL_7
#  undef XLAT_STR_8
#  undef XLAT_VAL_8
#  undef XLAT_STR_9
#  undef XLAT_VAL_9
#  undef XLAT_STR_10
#  undef XLAT_VAL_10
#  undef XLAT_STR_11
#  undef XLAT_VAL_11
#  undef XLAT_STR_12
#  undef XLAT_VAL_12
#  undef XLAT_STR_13
#  undef XLAT_VAL_13
#  undef XLAT_STR_14
#  undef XLAT_VAL_14
# endif /* !IN_MPERS */

#endif /* !XLAT_MACROS_ONLY */
